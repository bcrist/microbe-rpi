// Generated by https://github.com/bcrist/microbe-regz
const Mmio = @import("microbe").Mmio;

pub const SYSINFO = extern struct {
    CHIP_ID: Mmio(packed struct(u32) {
        MANUFACTURER: u12 = 0,
        PART: u16 = 0,
        REVISION: u4 = 0,
    }, .rw),
    PLATFORM: Mmio(packed struct(u32) {
        FPGA: u1 = 0,
        ASIC: u1 = 0,
        _reserved_2: u30 = 0,
    }, .rw),
    _reserved_8: [56]u8 = undefined,
    GITREF_RP2040: Mmio(u32, .r),
};

pub const SYSCFG = extern struct {
    PROC0_NMI_MASK: Mmio(u32, .rw),
    PROC1_NMI_MASK: Mmio(u32, .rw),
    PROC_CONFIG: Mmio(packed struct(u32) {
        PROC0_HALTED: u1 = 0,
        PROC1_HALTED: u1 = 0,
        _reserved_2: u22 = 0,
        PROC0_DAP_INSTID: u4 = 0,
        PROC1_DAP_INSTID: u4 = 1,
    }, .rw),
    PROC_IN_SYNC_BYPASS: Mmio(packed struct(u32) {
        PROC_IN_SYNC_BYPASS: u30 = 0,
        _reserved_1e: u2 = 0,
    }, .rw),
    PROC_IN_SYNC_BYPASS_HI: Mmio(packed struct(u32) {
        PROC_IN_SYNC_BYPASS_HI: u6 = 0,
        _reserved_6: u26 = 0,
    }, .rw),
    DBGFORCE: Mmio(packed struct(u32) {
        PROC0_SWDO: u1 = 0,
        PROC0_SWDI: u1 = 1,
        PROC0_SWCLK: u1 = 1,
        PROC0_ATTACH: u1 = 0,
        PROC1_SWDO: u1 = 0,
        PROC1_SWDI: u1 = 1,
        PROC1_SWCLK: u1 = 1,
        PROC1_ATTACH: u1 = 0,
        _reserved_8: u24 = 0,
    }, .rw),
    MEMPOWERDOWN: Mmio(packed struct(u32) {
        SRAM0: u1 = 0,
        SRAM1: u1 = 0,
        SRAM2: u1 = 0,
        SRAM3: u1 = 0,
        SRAM4: u1 = 0,
        SRAM5: u1 = 0,
        USB: u1 = 0,
        ROM: u1 = 0,
        _reserved_8: u24 = 0,
    }, .rw),
};

pub const INTERP = packed struct(u32) {
    SHIFT: u5 = 0,
    MASK_LSB: u5 = 0,
    MASK_MSB: u5 = 0,
    SIGNED: u1 = 0,
    CROSS_INPUT: u1 = 0,
    CROSS_RESULT: u1 = 0,
    ADD_RAW: u1 = 0,
    FORCE_MSB: u2 = 0,
    _reserved_15: u11 = 0,
};

pub const SIO = extern struct {
    CPUID: Mmio(u32, .r),
    GPIO_IN: Mmio(packed struct(u32) {
        GPIO_IN: u30 = 0,
        _reserved_1e: u2 = 0,
    }, .rw),
    GPIO_HI_IN: Mmio(packed struct(u32) {
        GPIO_HI_IN: u6 = 0,
        _reserved_6: u26 = 0,
    }, .rw),
    _reserved_c: [4]u8 = undefined,
    GPIO_OUT: Mmio(packed struct(u32) {
        GPIO_OUT: u30 = 0,
        _reserved_1e: u2 = 0,
    }, .rw),
    GPIO_OUT_SET: Mmio(packed struct(u32) {
        GPIO_OUT_SET: u30 = 0,
        _reserved_1e: u2 = 0,
    }, .rw),
    GPIO_OUT_CLR: Mmio(packed struct(u32) {
        GPIO_OUT_CLR: u30 = 0,
        _reserved_1e: u2 = 0,
    }, .rw),
    GPIO_OUT_XOR: Mmio(packed struct(u32) {
        GPIO_OUT_XOR: u30 = 0,
        _reserved_1e: u2 = 0,
    }, .rw),
    GPIO_OE: Mmio(packed struct(u32) {
        GPIO_OE: u30 = 0,
        _reserved_1e: u2 = 0,
    }, .rw),
    GPIO_OE_SET: Mmio(packed struct(u32) {
        GPIO_OE_SET: u30 = 0,
        _reserved_1e: u2 = 0,
    }, .rw),
    GPIO_OE_CLR: Mmio(packed struct(u32) {
        GPIO_OE_CLR: u30 = 0,
        _reserved_1e: u2 = 0,
    }, .rw),
    GPIO_OE_XOR: Mmio(packed struct(u32) {
        GPIO_OE_XOR: u30 = 0,
        _reserved_1e: u2 = 0,
    }, .rw),
    GPIO_HI_OUT: Mmio(packed struct(u32) {
        GPIO_HI_OUT: u6 = 0,
        _reserved_6: u26 = 0,
    }, .rw),
    GPIO_HI_OUT_SET: Mmio(packed struct(u32) {
        GPIO_HI_OUT_SET: u6 = 0,
        _reserved_6: u26 = 0,
    }, .rw),
    GPIO_HI_OUT_CLR: Mmio(packed struct(u32) {
        GPIO_HI_OUT_CLR: u6 = 0,
        _reserved_6: u26 = 0,
    }, .rw),
    GPIO_HI_OUT_XOR: Mmio(packed struct(u32) {
        GPIO_HI_OUT_XOR: u6 = 0,
        _reserved_6: u26 = 0,
    }, .rw),
    GPIO_HI_OE: Mmio(packed struct(u32) {
        GPIO_HI_OE: u6 = 0,
        _reserved_6: u26 = 0,
    }, .rw),
    GPIO_HI_OE_SET: Mmio(packed struct(u32) {
        GPIO_HI_OE_SET: u6 = 0,
        _reserved_6: u26 = 0,
    }, .rw),
    GPIO_HI_OE_CLR: Mmio(packed struct(u32) {
        GPIO_HI_OE_CLR: u6 = 0,
        _reserved_6: u26 = 0,
    }, .rw),
    GPIO_HI_OE_XOR: Mmio(packed struct(u32) {
        GPIO_HI_OE_XOR: u6 = 0,
        _reserved_6: u26 = 0,
    }, .rw),
    FIFO_ST: Mmio(packed struct(u32) {
        VLD: u1 = 0,
        RDY: u1 = 1,
        WOF: u1 = 0,
        ROE: u1 = 0,
        _reserved_4: u28 = 0,
    }, .rw),
    FIFO_WR: Mmio(u32, .w),
    FIFO_RD: Mmio(u32, .r),
    SPINLOCK_ST: Mmio(u32, .r),
    DIV_UDIVIDEND: Mmio(u32, .rw),
    DIV_UDIVISOR: Mmio(u32, .rw),
    DIV_SDIVIDEND: Mmio(u32, .rw),
    DIV_SDIVISOR: Mmio(u32, .rw),
    DIV_QUOTIENT: Mmio(u32, .rw),
    DIV_REMAINDER: Mmio(u32, .rw),
    DIV_CSR: Mmio(packed struct(u32) {
        READY: u1 = 1,
        DIRTY: u1 = 0,
        _reserved_2: u30 = 0,
    }, .rw),
    _reserved_7c: [4]u8 = undefined,
    INTERP0_ACCUM0: Mmio(u32, .rw),
    INTERP0_ACCUM1: Mmio(u32, .rw),
    INTERP0_BASE0: Mmio(u32, .rw),
    INTERP0_BASE1: Mmio(u32, .rw),
    INTERP0_BASE2: Mmio(u32, .rw),
    INTERP0_POP_LANE0: Mmio(u32, .r),
    INTERP0_POP_LANE1: Mmio(u32, .r),
    INTERP0_POP_FULL: Mmio(u32, .r),
    INTERP0_PEEK_LANE0: Mmio(u32, .r),
    INTERP0_PEEK_LANE1: Mmio(u32, .r),
    INTERP0_PEEK_FULL: Mmio(u32, .r),
    INTERP0_CTRL_LANE0: Mmio(packed struct(u32) {
        SHIFT: u5 = 0,
        MASK_LSB: u5 = 0,
        MASK_MSB: u5 = 0,
        SIGNED: u1 = 0,
        CROSS_INPUT: u1 = 0,
        CROSS_RESULT: u1 = 0,
        ADD_RAW: u1 = 0,
        FORCE_MSB: u2 = 0,
        BLEND: u1 = 0,
        _reserved_16: u1 = 0,
        OVERF0: u1 = 0,
        OVERF1: u1 = 0,
        OVERF: u1 = 0,
        _reserved_1a: u6 = 0,
    }, .rw),
    INTERP0_CTRL_LANE1: Mmio(INTERP, .rw),
    INTERP0_ACCUM0_ADD: Mmio(packed struct(u32) {
        INTERP0_ACCUM0_ADD: u24 = 0,
        _reserved_18: u8 = 0,
    }, .rw),
    INTERP0_ACCUM1_ADD: Mmio(packed struct(u32) {
        INTERP0_ACCUM1_ADD: u24 = 0,
        _reserved_18: u8 = 0,
    }, .rw),
    INTERP0_BASE_1AND0: Mmio(u32, .w),
    INTERP1_ACCUM0: Mmio(u32, .rw),
    INTERP1_ACCUM1: Mmio(u32, .rw),
    INTERP1_BASE0: Mmio(u32, .rw),
    INTERP1_BASE1: Mmio(u32, .rw),
    INTERP1_BASE2: Mmio(u32, .rw),
    INTERP1_POP_LANE0: Mmio(u32, .r),
    INTERP1_POP_LANE1: Mmio(u32, .r),
    INTERP1_POP_FULL: Mmio(u32, .r),
    INTERP1_PEEK_LANE0: Mmio(u32, .r),
    INTERP1_PEEK_LANE1: Mmio(u32, .r),
    INTERP1_PEEK_FULL: Mmio(u32, .r),
    INTERP1_CTRL_LANE0: Mmio(packed struct(u32) {
        SHIFT: u5 = 0,
        MASK_LSB: u5 = 0,
        MASK_MSB: u5 = 0,
        SIGNED: u1 = 0,
        CROSS_INPUT: u1 = 0,
        CROSS_RESULT: u1 = 0,
        ADD_RAW: u1 = 0,
        FORCE_MSB: u2 = 0,
        _reserved_15: u1 = 0,
        CLAMP: u1 = 0,
        OVERF0: u1 = 0,
        OVERF1: u1 = 0,
        OVERF: u1 = 0,
        _reserved_1a: u6 = 0,
    }, .rw),
    INTERP1_CTRL_LANE1: Mmio(INTERP, .rw),
    INTERP1_ACCUM0_ADD: Mmio(packed struct(u32) {
        INTERP1_ACCUM0_ADD: u24 = 0,
        _reserved_18: u8 = 0,
    }, .rw),
    INTERP1_ACCUM1_ADD: Mmio(packed struct(u32) {
        INTERP1_ACCUM1_ADD: u24 = 0,
        _reserved_18: u8 = 0,
    }, .rw),
    INTERP1_BASE_1AND0: Mmio(u32, .w),
    SPINLOCK0: Mmio(u32, .rw),
    SPINLOCK1: Mmio(u32, .rw),
    SPINLOCK2: Mmio(u32, .rw),
    SPINLOCK3: Mmio(u32, .rw),
    SPINLOCK4: Mmio(u32, .rw),
    SPINLOCK5: Mmio(u32, .rw),
    SPINLOCK6: Mmio(u32, .rw),
    SPINLOCK7: Mmio(u32, .rw),
    SPINLOCK8: Mmio(u32, .rw),
    SPINLOCK9: Mmio(u32, .rw),
    SPINLOCK10: Mmio(u32, .rw),
    SPINLOCK11: Mmio(u32, .rw),
    SPINLOCK12: Mmio(u32, .rw),
    SPINLOCK13: Mmio(u32, .rw),
    SPINLOCK14: Mmio(u32, .rw),
    SPINLOCK15: Mmio(u32, .rw),
    SPINLOCK16: Mmio(u32, .rw),
    SPINLOCK17: Mmio(u32, .rw),
    SPINLOCK18: Mmio(u32, .rw),
    SPINLOCK19: Mmio(u32, .rw),
    SPINLOCK20: Mmio(u32, .rw),
    SPINLOCK21: Mmio(u32, .rw),
    SPINLOCK22: Mmio(u32, .rw),
    SPINLOCK23: Mmio(u32, .rw),
    SPINLOCK24: Mmio(u32, .rw),
    SPINLOCK25: Mmio(u32, .rw),
    SPINLOCK26: Mmio(u32, .rw),
    SPINLOCK27: Mmio(u32, .rw),
    SPINLOCK28: Mmio(u32, .rw),
    SPINLOCK29: Mmio(u32, .rw),
    SPINLOCK30: Mmio(u32, .rw),
    SPINLOCK31: Mmio(u32, .rw),
};

pub const VREG_AND_CHIP_RESET = extern struct {
    VREG: Mmio(packed struct(u32) {
        EN: u1 = 1,
        HIZ: u1 = 0,
        _reserved_2: u2 = 0,
        VSEL: u4 = 0xB,
        _reserved_8: u4 = 0,
        ROK: u1 = 0,
        _reserved_d: u19 = 0,
    }, .rw),
    BOD: Mmio(packed struct(u32) {
        EN: u1 = 1,
        _reserved_1: u3 = 0,
        VSEL: u4 = 9,
        _reserved_8: u24 = 0,
    }, .rw),
    CHIP_RESET: Mmio(packed struct(u32) {
        _reserved_0: u8 = 0,
        HAD_POR: u1 = 0,
        _reserved_9: u7 = 0,
        HAD_RUN: u1 = 0,
        _reserved_11: u3 = 0,
        HAD_PSM_RESTART: u1 = 0,
        _reserved_15: u3 = 0,
        PSM_RESTART_FLAG: u1 = 0,
        _reserved_19: u7 = 0,
    }, .rw),
};

pub const PERFSEL = enum(u5) {
    apb_contested = 0x0,
    apb = 0x1,
    fastperi_contested = 0x2,
    fastperi = 0x3,
    sram5_contested = 0x4,
    sram5 = 0x5,
    sram4_contested = 0x6,
    sram4 = 0x7,
    sram3_contested = 0x8,
    sram3 = 0x9,
    sram2_contested = 0xA,
    sram2 = 0xB,
    sram1_contested = 0xC,
    sram1 = 0xD,
    sram0_contested = 0xE,
    sram0 = 0xF,
    xip_main_contested = 0x10,
    xip_main = 0x11,
    rom_contested = 0x12,
    rom = 0x13,
    _,
};

pub const BUSCTRL = extern struct {
    BUS_PRIORITY: Mmio(packed struct(u32) {
        PROC0: u1 = 0,
        _reserved_1: u3 = 0,
        PROC1: u1 = 0,
        _reserved_5: u3 = 0,
        DMA_R: u1 = 0,
        _reserved_9: u3 = 0,
        DMA_W: u1 = 0,
        _reserved_d: u19 = 0,
    }, .rw),
    BUS_PRIORITY_ACK: Mmio(packed struct(u32) {
        BUS_PRIORITY_ACK: u1 = 0,
        _reserved_1: u31 = 0,
    }, .rw),
    PERFCTR0: Mmio(packed struct(u32) {
        PERFCTR0: u24 = 0,
        _reserved_18: u8 = 0,
    }, .rw),
    PERFSEL0: Mmio(packed struct(u32) {
        PERFSEL0: PERFSEL = @enumFromInt(31),
        _reserved_5: u27 = 0,
    }, .rw),
    PERFCTR1: Mmio(packed struct(u32) {
        PERFCTR1: u24 = 0,
        _reserved_18: u8 = 0,
    }, .rw),
    PERFSEL1: Mmio(packed struct(u32) {
        PERFSEL1: PERFSEL = @enumFromInt(31),
        _reserved_5: u27 = 0,
    }, .rw),
    PERFCTR2: Mmio(packed struct(u32) {
        PERFCTR2: u24 = 0,
        _reserved_18: u8 = 0,
    }, .rw),
    PERFSEL2: Mmio(packed struct(u32) {
        PERFSEL2: PERFSEL = @enumFromInt(31),
        _reserved_5: u27 = 0,
    }, .rw),
    PERFCTR3: Mmio(packed struct(u32) {
        PERFCTR3: u24 = 0,
        _reserved_18: u8 = 0,
    }, .rw),
    PERFSEL3: Mmio(packed struct(u32) {
        PERFSEL3: PERFSEL = @enumFromInt(31),
        _reserved_5: u27 = 0,
    }, .rw),
};

pub const RESET_DONE = packed struct(u32) {
    adc: u1 = 0,
    busctrl: u1 = 0,
    dma: u1 = 0,
    i2c0: u1 = 0,
    i2c1: u1 = 0,
    io_bank0: u1 = 0,
    io_qspi: u1 = 0,
    jtag: u1 = 0,
    pads_bank0: u1 = 0,
    pads_qspi: u1 = 0,
    pio0: u1 = 0,
    pio1: u1 = 0,
    pll_sys: u1 = 0,
    pll_usb: u1 = 0,
    pwm: u1 = 0,
    rtc: u1 = 0,
    spi0: u1 = 0,
    spi1: u1 = 0,
    syscfg: u1 = 0,
    sysinfo: u1 = 0,
    tbman: u1 = 0,
    timer: u1 = 0,
    uart0: u1 = 0,
    uart1: u1 = 0,
    usbctrl: u1 = 0,
    _reserved_19: u7 = 0,
};

pub const RESETS = extern struct {
    RESET: Mmio(packed struct(u32) {
        adc: u1 = 1,
        busctrl: u1 = 1,
        dma: u1 = 1,
        i2c0: u1 = 1,
        i2c1: u1 = 1,
        io_bank0: u1 = 1,
        io_qspi: u1 = 1,
        jtag: u1 = 1,
        pads_bank0: u1 = 1,
        pads_qspi: u1 = 1,
        pio0: u1 = 1,
        pio1: u1 = 1,
        pll_sys: u1 = 1,
        pll_usb: u1 = 1,
        pwm: u1 = 1,
        rtc: u1 = 1,
        spi0: u1 = 1,
        spi1: u1 = 1,
        syscfg: u1 = 1,
        sysinfo: u1 = 1,
        tbman: u1 = 1,
        timer: u1 = 1,
        uart0: u1 = 1,
        uart1: u1 = 1,
        usbctrl: u1 = 1,
        _reserved_19: u7 = 0,
    }, .rw),
    WDSEL: Mmio(RESET_DONE, .rw),
    RESET_DONE: Mmio(RESET_DONE, .rw),
};

pub const DONE = packed struct(u32) {
    rosc: u1 = 0,
    xosc: u1 = 0,
    clocks: u1 = 0,
    resets: u1 = 0,
    busfabric: u1 = 0,
    rom: u1 = 0,
    sram0: u1 = 0,
    sram1: u1 = 0,
    sram2: u1 = 0,
    sram3: u1 = 0,
    sram4: u1 = 0,
    sram5: u1 = 0,
    xip: u1 = 0,
    vreg_and_chip_reset: u1 = 0,
    sio: u1 = 0,
    proc0: u1 = 0,
    proc1: u1 = 0,
    _reserved_11: u15 = 0,
};

pub const PSM = extern struct {
    FRCE_ON: Mmio(DONE, .rw),
    FRCE_OFF: Mmio(DONE, .rw),
    WDSEL: Mmio(DONE, .rw),
    DONE: Mmio(DONE, .rw),
};

pub const WATCHDOG = extern struct {
    CTRL: Mmio(packed struct(u32) {
        TIME: u24 = 0,
        PAUSE_JTAG: u1 = 1,
        PAUSE_DBG0: u1 = 1,
        PAUSE_DBG1: u1 = 1,
        _reserved_1b: u3 = 0,
        ENABLE: u1 = 0,
        TRIGGER: u1 = 0,
    }, .rw),
    LOAD: Mmio(packed struct(u32) {
        LOAD: u24 = 0,
        _reserved_18: u8 = 0,
    }, .rw),
    REASON: Mmio(packed struct(u32) {
        TIMER: u1 = 0,
        FORCE: u1 = 0,
        _reserved_2: u30 = 0,
    }, .rw),
    SCRATCH0: Mmio(u32, .rw),
    SCRATCH1: Mmio(u32, .rw),
    SCRATCH2: Mmio(u32, .rw),
    SCRATCH3: Mmio(u32, .rw),
    SCRATCH4: Mmio(u32, .rw),
    SCRATCH5: Mmio(u32, .rw),
    SCRATCH6: Mmio(u32, .rw),
    SCRATCH7: Mmio(u32, .rw),
    TICK: Mmio(packed struct(u32) {
        CYCLES: u9 = 0,
        ENABLE: u1 = 1,
        RUNNING: u1 = 0,
        COUNT: u9 = 0,
        _reserved_14: u12 = 0,
    }, .rw),
};

pub const XIP_CTRL = extern struct {
    CTRL: Mmio(packed struct(u32) {
        EN: u1 = 1,
        ERR_BADWRITE: u1 = 1,
        _reserved_2: u1 = 0,
        POWER_DOWN: u1 = 0,
        _reserved_4: u28 = 0,
    }, .rw),
    FLUSH: Mmio(packed struct(u32) {
        FLUSH: u1 = 0,
        _reserved_1: u31 = 0,
    }, .rw),
    STAT: Mmio(packed struct(u32) {
        FLUSH_READY: u1 = 0,
        FIFO_EMPTY: u1 = 1,
        FIFO_FULL: u1 = 0,
        _reserved_3: u29 = 0,
    }, .rw),
    CTR_HIT: Mmio(u32, .rw),
    CTR_ACC: Mmio(u32, .rw),
    STREAM_ADDR: Mmio(packed struct(u32) {
        _reserved_0: u2 = 0,
        STREAM_ADDR: u30 = 0,
    }, .rw),
    STREAM_CTR: Mmio(packed struct(u32) {
        STREAM_CTR: u22 = 0,
        _reserved_16: u10 = 0,
    }, .rw),
    STREAM_FIFO: Mmio(u32, .r),
};

pub const SSI = extern struct {
    control_0: Mmio(packed struct(u32) {
        _reserved_0: u4 = 0,
        frame_format: enum(u2) {
            spi = 0,
            ssp = 1,
            microwire = 2,
            _,
        } = .spi,
        clock_phase: u1 = 0,
        clock_polarity: u1 = 0,
        transfer_mode: enum(u2) {
            tx_and_rx = 0,

            /// not for SPI_frame_format == .standard
            tx_only = 1,

            /// not for SPI_frame_format == .standard
            rx_only = 2,

            /// tx then rx
            eeprom_read = 3,
        } = .tx_and_rx,
        slave_output_enable: u1 = 0,

        /// test mode
        shift_register_loop: u1 = 0,

        control_frame_size: enum(u4) {
            _1_bit = 0,
            _2_bits = 1,
            _3_bits = 2,
            _4_bits = 3,
            _5_bits = 4,
            _6_bits = 5,
            _7_bits = 6,
            _8_bits = 7,
            _9_bits = 8,
            _10_bits = 9,
            _11_bits = 10,
            _12_bits = 11,
            _13_bits = 12,
            _14_bits = 13,
            _15_bits = 14,
            _16_bits = 15,
        } = ._1_bit,
        data_frame_size: enum(u5) {
            _1_bit = 0x0,
            _2_bits = 0x1,
            _3_bits = 0x2,
            _4_bits = 0x3,
            _5_bits = 0x4,
            _6_bits = 0x5,
            _7_bits = 0x6,
            _8_bits = 0x7,
            _9_bits = 0x8,
            _10_bits = 0x9,
            _11_bits = 0xA,
            _12_bits = 0xB,
            _13_bits = 0xC,
            _14_bits = 0xD,
            _15_bits = 0xE,
            _16_bits = 0xF,
            _17_bits = 0x10,
            _18_bits = 0x11,
            _19_bits = 0x12,
            _20_bits = 0x13,
            _21_bits = 0x14,
            _22_bits = 0x15,
            _23_bits = 0x16,
            _24_bits = 0x17,
            _25_bits = 0x18,
            _26_bits = 0x19,
            _27_bits = 0x1A,
            _28_bits = 0x1B,
            _29_bits = 0x1C,
            _30_bits = 0x1D,
            _31_bits = 0x1E,
            _32_bits = 0x1F,
        } = ._1_bit,

        /// Only valid when frame_format is .spi
        spi_frame_format: enum(u2) {
            standard = 0,
            dual = 1,
            quad = 2,
            _,
        } = .standard,

        _reserved_17: u1 = 0,
        slave_select_toggle_enable: u1 = 0,
        _reserved_19: u7 = 0,
    }, .rw),
    control_1: Mmio(packed struct(u32) {
        /// N+1 data frames will be transferred
        num_data_frames: u16 = 0,

        _reserved_10: u16 = 0,
    }, .rw),
    enable: Mmio(packed struct(u32) {
        enable: bool = false,
        _reserved_1: u31 = 0,
    }, .rw),
    MWCR: Mmio(packed struct(u32) {
        MWMOD: u1 = 0,
        MDD: u1 = 0,
        MHS: u1 = 0,
        _reserved_3: u29 = 0,
    }, .rw),
    SER: Mmio(packed struct(u32) {
        SER: u1 = 0,
        _reserved_1: u31 = 0,
    }, .rw),
    baud_rate: Mmio(packed struct(u32) {
        /// LSB must be 0
        clock_divisor: u16 = 0,

        _reserved_10: u16 = 0,
    }, .rw),
    TXFTLR: Mmio(packed struct(u32) {
        TFT: u8 = 0,
        _reserved_8: u24 = 0,
    }, .rw),
    RXFTLR: Mmio(packed struct(u32) {
        RFT: u8 = 0,
        _reserved_8: u24 = 0,
    }, .rw),
    TXFLR: Mmio(packed struct(u32) {
        TFTFL: u8 = 0,
        _reserved_8: u24 = 0,
    }, .rw),
    RXFLR: Mmio(packed struct(u32) {
        RXTFL: u8 = 0,
        _reserved_8: u24 = 0,
    }, .rw),
    status: Mmio(packed struct(u32) {
        busy: bool = false,
        tx_fifo_not_full: bool = false,
        tx_fifo_empty: bool = false,
        rx_fifo_not_empty: bool = false,
        rx_fifo_full: bool = false,
        tx_error_flag: bool = false,
        data_collision_error_flag: bool = false,
        _reserved_7: u25 = 0,
    }, .r),
    IMR: Mmio(packed struct(u32) {
        TXEIM: u1 = 0,
        TXOIM: u1 = 0,
        RXUIM: u1 = 0,
        RXOIM: u1 = 0,
        RXFIM: u1 = 0,
        MSTIM: u1 = 0,
        _reserved_6: u26 = 0,
    }, .rw),
    ISR: Mmio(packed struct(u32) {
        TXEIS: u1 = 0,
        TXOIS: u1 = 0,
        RXUIS: u1 = 0,
        RXOIS: u1 = 0,
        RXFIS: u1 = 0,
        MSTIS: u1 = 0,
        _reserved_6: u26 = 0,
    }, .rw),
    RISR: Mmio(packed struct(u32) {
        TXEIR: u1 = 0,
        TXOIR: u1 = 0,
        RXUIR: u1 = 0,
        RXOIR: u1 = 0,
        RXFIR: u1 = 0,
        MSTIR: u1 = 0,
        _reserved_6: u26 = 0,
    }, .rw),
    TXOICR: Mmio(packed struct(u32) {
        TXOICR: u1 = 0,
        _reserved_1: u31 = 0,
    }, .rw),
    RXOICR: Mmio(packed struct(u32) {
        RXOICR: u1 = 0,
        _reserved_1: u31 = 0,
    }, .rw),
    RXUICR: Mmio(packed struct(u32) {
        RXUICR: u1 = 0,
        _reserved_1: u31 = 0,
    }, .rw),
    MSTICR: Mmio(packed struct(u32) {
        MSTICR: u1 = 0,
        _reserved_1: u31 = 0,
    }, .rw),
    ICR: Mmio(packed struct(u32) {
        ICR: u1 = 0,
        _reserved_1: u31 = 0,
    }, .rw),
    DMACR: Mmio(packed struct(u32) {
        RDMAE: u1 = 0,
        TDMAE: u1 = 0,
        _reserved_2: u30 = 0,
    }, .rw),
    DMATDLR: Mmio(packed struct(u32) {
        DMATDL: u8 = 0,
        _reserved_8: u24 = 0,
    }, .rw),
    DMARDLR: Mmio(packed struct(u32) {
        DMARDL: u8 = 0,
        _reserved_8: u24 = 0,
    }, .rw),
    IDR: Mmio(u32, .rw),
    SSI_VERSION_ID: Mmio(u32, .rw),
    data: [36]Mmio(u32, .rw),
    rx_sample_delay: Mmio(packed struct(u32) {
        delay: u8 = 0,
        _reserved_8: u24 = 0,
    }, .rw),
    spi_control: Mmio(packed struct(u32) {
        transfer_format: enum(u1) {
            standard_command_standard_address = 0,
            standard_command_wide_address = 1,
            wide_command_wide_address = 1,
        } = .standard_command_standard_address,
        _reserved_1: u1 = 0,
        address_length: enum(u4) {
            none = 0,
            _4_bits = 1,
            _8_bits = 2,
            _12_bits = 3,
            _16_bits = 4,
            _20_bits = 5,
            _24_bits = 6,
            _28_bits = 7,
            _32_bits = 8,
            _36_bits = 9,
            _40_bits = 10,
            _44_bits = 11,
            _48_bits = 12,
            _52_bits = 13,
            _56_bits = 14,
            _60_bits = 15,
        } = .none,
        _reserved_6: u2 = 0,
        command_length: enum(u2) {
            none = 0,
            _4_bits = 1,
            _8_bits = 2,
            _16_bits = 3,
        } = .none,
        _reserved_a: u1 = 0,
        wait_cycles_after_mode: u5 = 0,
        ddr_address_and_data: bool = false,
        ddr_command: bool = false,
        enable_read_data_strobe: bool = false,
        _reserved_13: u5 = 0,

        /// When command_length is 8 bits, this command is sent for each XIP transfer.
        /// When command_length is 0, it is appended to the address.
        xip_command_or_mode: u8 = 3,
    }, .rw),
    TXD_DRIVE_EDGE: Mmio(packed struct(u32) {
        TDE: u8 = 0,
        _reserved_8: u24 = 0,
    }, .rw),
};

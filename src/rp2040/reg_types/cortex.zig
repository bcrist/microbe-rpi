// Generated by https://github.com/bcrist/microbe-regz
const Mmio = @import("microbe").Mmio;

pub const InterruptBitmap = packed struct(u32) {
    TIMER_IRQ_0: bool = false,
    TIMER_IRQ_1: bool = false,
    TIMER_IRQ_2: bool = false,
    TIMER_IRQ_3: bool = false,
    PWM_IRQ_WRAP: bool = false,
    USBCTRL_IRQ: bool = false,
    XIP_IRQ: bool = false,
    PIO0_IRQ_0: bool = false,
    PIO0_IRQ_1: bool = false,
    PIO1_IRQ_0: bool = false,
    PIO1_IRQ_1: bool = false,
    DMA_IRQ_0: bool = false,
    DMA_IRQ_1: bool = false,
    IO_IRQ_BANK0: bool = false,
    IO_IRQ_QSPI: bool = false,
    SIO_IRQ_PROC0: bool = false,
    SIO_IRQ_PROC1: bool = false,
    CLOCKS_IRQ: bool = false,
    SPI0_IRQ: bool = false,
    SPI1_IRQ: bool = false,
    UART0_IRQ: bool = false,
    UART1_IRQ: bool = false,
    ADC_IRQ_FIFO: bool = false,
    I2C0_IRQ: bool = false,
    I2C1_IRQ: bool = false,
    RTC_IRQ: bool = false,
    _reserved_1a: u6 = 0,
};

pub const NVIC = extern struct {
    /// a.k.a. ISER
    interrupt_set_enable: Mmio(InterruptBitmap, .rw),

    _reserved_4: [124]u8 = undefined,

    /// a.k.a. ICER
    interrupt_clear_enable: Mmio(InterruptBitmap, .rw),

    _reserved_84: [124]u8 = undefined,

    /// a.k.a. ISPR
    interrupt_set_pending: Mmio(InterruptBitmap, .rw),

    _reserved_104: [124]u8 = undefined,

    /// a.k.a. ICPR
    interrupt_clear_pending: Mmio(InterruptBitmap, .rw),

    _reserved_184: [636]u8 = undefined,
    interrupt_priority_0: Mmio(packed struct(u32) {
        TIMER_IRQ_0: u8 = 0,
        TIMER_IRQ_1: u8 = 0,
        TIMER_IRQ_2: u8 = 0,
        TIMER_IRQ_3: u8 = 0,
    }, .rw),
    interrupt_priority_1: Mmio(packed struct(u32) {
        PWM_IRQ_WRAP: u8 = 0,
        USBCTRL_IRQ: u8 = 0,
        XIP_IRQ: u8 = 0,
        PIO0_IRQ_0: u8 = 0,
    }, .rw),
    interrupt_priority_2: Mmio(packed struct(u32) {
        PIO0_IRQ_1: u8 = 0,
        PIO1_IRQ_0: u8 = 0,
        PIO1_IRQ_1: u8 = 0,
        DMA_IRQ_0: u8 = 0,
    }, .rw),
    interrupt_priority_3: Mmio(packed struct(u32) {
        DMA_IRQ_1: u8 = 0,
        IO_IRQ_BANK0: u8 = 0,
        IO_IRQ_QSPI: u8 = 0,
        SIO_IRQ_PROC0: u8 = 0,
    }, .rw),
    interrupt_priority_4: Mmio(packed struct(u32) {
        SIO_IRQ_PROC1: u8 = 0,
        CLOCKS_IRQ: u8 = 0,
        SPI0_IRQ: u8 = 0,
        SPI1_IRQ: u8 = 0,
    }, .rw),
    interrupt_priority_5: Mmio(packed struct(u32) {
        UART0_IRQ: u8 = 0,
        UART1_IRQ: u8 = 0,
        ADC_IRQ_FIFO: u8 = 0,
        I2C0_IRQ: u8 = 0,
    }, .rw),
    interrupt_priority_6: Mmio(packed struct(u32) {
        I2C1_IRQ: u8 = 0,
        RTC_IRQ: u8 = 0,
        _reserved_10: u16 = 0,
    }, .rw),
    interrupt_priority_7: Mmio(packed struct(u32) {
        _reserved_0: u32 = 0,
    }, .rw),
};

pub const SYSTICK = extern struct {
    control_status: Mmio(packed struct(u32) {
        count_enable: bool = false,

        /// Note the interrupt is triggered even if overflow_flag has not been cleared since the last overflow
        overflow_interrupt_enable: bool = false,

        clock_source: enum(u1) {
            watchdog_tick = 0x0,
            clk_sys = 0x1,
        } = .watchdog_tick,
        _reserved_3: u13 = 0,

        /// Read-only; resets to 0 when read
        overflow_flag: bool = false,

        _reserved_11: u15 = 0,
    }, .rw),
    reload_value: Mmio(packed struct(u32) {
        value: u24 = 0,
        _reserved_18: u8 = 0,
    }, .rw),
    current_value: Mmio(packed struct(u32) {
        value: u24 = 0,
        _reserved_18: u8 = 0,
    }, .rw),
    calibration: Mmio(packed struct(u32) {
        ten_ms_count: u24 = 0,
        _reserved_18: u6 = 0,
        calibration_inexact: bool = false,
        no_ref_clock: bool = false,
    }, .r),
};

pub const Exception = @import("chip").Exception;

pub const VectorTablePointer = @import("vt.zig").VectorTablePointer;

pub const SCB = extern struct {
    /// a.k.a. CPUID
    chip_id: Mmio(packed struct(u32) {
        revision: u4 = 1,
        part_num: u12 = 0xC60,
        architecture: u4 = 0xC,
        variant: u4 = 0,
        implementer: u8 = 0x41,
    }, .r),

    /// a.k.a. ICSR
    interrupt_control_state: Mmio(packed struct(u32) {
        active_exception_number: Exception = @enumFromInt(0x0),
        _reserved_9: u3 = 0,
        pending_exception_number: Exception = @enumFromInt(0x0),
        _reserved_15: u1 = 0,

        /// Only includes external interrupts (i.e. exception number >= 16)
        interrupt_pending: bool = false,

        /// Only available when core is halted
        isr_preempt: bool = false,

        _reserved_18: u1 = 0,
        clear_pending_SysTick: bool = false,

        /// reads true if SysTick is pending
        set_pending_SysTick: bool = false,

        clear_pending_PendSV: bool = false,

        /// reads true if PendSV is pending
        set_pending_PendSV: bool = false,

        _reserved_1d: u2 = 0,

        /// reads true if NMI is pending
        set_pending_NMI: bool = false,
    }, .rw),

    /// N.B. The vector table must be align(256)!
    /// a.k.a. VTOR
    vector_table: Mmio(VectorTablePointer, .rw),

    /// a.k.a. AIRCR
    reset_control: Mmio(packed struct(u32) {
        _reserved_0: u1 = 0,

        /// Only available when core is halted
        request_clear_active_exception: bool = false,

        request_core_reset: bool = false,
        _reserved_3: u12 = 0,
        endianness: enum(u1) {
            little = 0x0,
            big = 0x1,
        } = .little,
        vector_key: u16 = 0x5FA,
    }, .rw),

    /// a.k.a. SCR
    system_control: Mmio(packed struct(u32) {
        _reserved_0: u1 = 0,
        sleep_on_exception_exit: bool = false,
        deep_sleep_enable: bool = false,
        _reserved_3: u1 = 0,
        send_event_on_pending_interrupt: bool = false,
        _reserved_5: u27 = 0,
    }, .rw),

    /// a.k.a. CCR
    configuration: Mmio(packed struct(u32) {
        _reserved_0: u3 = 0,
        unaligned_access_is_HardFault: bool = true,
        _reserved_4: u5 = 0,
        exception_stack_align_8: bool = true,
        _reserved_a: u22 = 0,
    }, .r),

    _reserved_18: [4]u8 = undefined,

    /// a.k.a. SHPR2
    exception_priority_2: Mmio(packed struct(u32) {
        _reserved_0: u24 = 0,
        SVCall: u8 = 0,
    }, .rw),

    /// a.k.a. SHPR3
    exception_priority_3: Mmio(packed struct(u32) {
        _reserved_0: u16 = 0,
        PendSV: u8 = 0,
        SysTick: u8 = 0,
    }, .rw),

    /// a.k.a. SHCSR
    exception_control_state: Mmio(packed struct(u32) {
        _reserved_0: u15 = 0,

        /// For debug use only; use SVC instruction to trigger SVCall from code.
        pending_SVCall: bool = false,

        _reserved_10: u16 = 0,
    }, .rw),
};

pub const MPU = extern struct {
    TYPE: Mmio(packed struct(u32) {
        SEPARATE: u1 = 0,
        _reserved_1: u7 = 0,
        DREGION: u8 = 0,
        IREGION: u8 = 0,
        _reserved_18: u8 = 0,
    }, .r),
    CTRL: Mmio(packed struct(u32) {
        ENABLE: u1 = 0,
        HFNMIENA: u1 = 0,
        PRIVDEFENA: u1 = 0,
        _reserved_3: u29 = 0,
    }, .rw),
    RNR: Mmio(packed struct(u32) {
        REGION: u4 = 0,
        _reserved_4: u28 = 0,
    }, .rw),
    RBAR: Mmio(packed struct(u32) {
        REGION: u4 = 0,
        VALID: u1 = 0,
        _reserved_5: u3 = 0,
        ADDR: u24 = 0,
    }, .rw),
    RASR: Mmio(packed struct(u32) {
        ENABLE: u1 = 0,
        SIZE: u5 = 0,
        _reserved_6: u2 = 0,
        SRD: u8 = 0,
        B: u1 = 0,
        C: u1 = 0,
        S: u1 = 0,
        _reserved_13: u5 = 0,
        AP: u3 = 0,
        _reserved_1b: u1 = 0,
        XN: u1 = 0,
        _reserved_1d: u3 = 0,
    }, .rw),
};

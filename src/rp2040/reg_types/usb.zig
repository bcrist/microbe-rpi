// Generated by https://github.com/bcrist/microbe-regz
const microbe = @import("microbe");
const chip = @import("chip");
const MMIO = microbe.MMIO;

pub const Transfer_Kind = microbe.usb.endpoint.Transfer_Kind;

pub const PID = microbe.usb.PID;

pub const Double_Buffer_Offset = enum(u2) {
    @"128" = 0,
    @"256" = 1,
    @"512" = 2,
    @"1024" = 3,
};

pub const Device_Endpoint_Control = packed struct(u32) {
    _reserved_0: u6 = 0,
    buffer_base: u10 = 0,
    enable_interrupt_on_nak: bool = false,
    enable_interrupt_on_stall: bool = false,
    _reserved_12: u8 = 0,
    transfer_kind: Transfer_Kind = microbe.util.from_int(Transfer_Kind, 0),
    enable_double_buffer_interrupt: bool = false,
    enable_buffer_interrupt: bool = false,
    double_buffered: bool = false,
    enabled: bool = false,
};

pub const Endpoint_Control_IO = extern union {
    host: extern struct {
        in: MMIO(packed struct(u32) {
            _reserved_0: u6 = 0,
            buffer_base: u10 = 0,
            poll_interval_ms_minus_one: u10 = 0,
            transfer_kind: Transfer_Kind = microbe.util.from_int(Transfer_Kind, 0),
            enable_double_buffer_interrupt: bool = false,
            enable_buffer_interrupt: bool = false,
            double_buffered: bool = false,
            enabled: bool = false,
        }, .rw),
        _reserved_4: [4]u8 = undefined,
    },
    device: extern struct {
        in: MMIO(Device_Endpoint_Control, .rw),
        out: MMIO(Device_Endpoint_Control, .rw),
    },
};

pub const Device_Buffer_Control_0 = packed struct(u16) {
    len: u10 = 0,
    transfer_pending: bool = false,
    send_stall: bool = false,
    force_buffer_0: bool = false,
    pid: PID = microbe.util.from_int(PID, 0),
    final_transfer: bool = false,
    full: bool = false,
};

pub const Device_Buffer_Control_1 = packed struct(u16) {
    len: u10 = 0,
    transfer_pending: bool = false,
    offset: Double_Buffer_Offset = .@"128",
    pid: PID = microbe.util.from_int(PID, 0),
    final_transfer: bool = false,
    full: bool = false,
};

pub const Buffer_Control_IO = extern union {
    host: extern struct {
        in0: MMIO(packed struct(u16) {
            len: u10 = 0,
            transfer_pending: bool = false,
            stall_received: bool = false,
            _reserved_c: u1 = 0,
            pid: PID = microbe.util.from_int(PID, 0),
            final_transfer: bool = false,
            full: bool = false,
        }, .rw),
        in1: MMIO(packed struct(u16) {
            len: u10 = 0,
            transfer_pending: bool = false,
            offset: Double_Buffer_Offset = .@"128",
            pid: PID = microbe.util.from_int(PID, 0),
            final_transfer: bool = false,
            full: bool = false,
        }, .rw),
        _reserved_4: [4]u8 = undefined,
    },
    device: extern struct {
        in0: MMIO(Device_Buffer_Control_0, .rw),
        in1: MMIO(Device_Buffer_Control_1, .rw),
        out0: MMIO(Device_Buffer_Control_0, .rw),
        out1: MMIO(Device_Buffer_Control_1, .rw),
    },
};

pub const USB_BUF = extern struct {
    setup_packet_low: MMIO(u32, .r),
    setup_packet_high: MMIO(u32, .r),
    ep_control: extern struct {
        ep1: Endpoint_Control_IO,
        ep2: Endpoint_Control_IO,
        ep3: Endpoint_Control_IO,
        ep4: Endpoint_Control_IO,
        ep5: Endpoint_Control_IO,
        ep6: Endpoint_Control_IO,
        ep7: Endpoint_Control_IO,
        ep8: Endpoint_Control_IO,
        ep9: Endpoint_Control_IO,
        ep10: Endpoint_Control_IO,
        ep11: Endpoint_Control_IO,
        ep12: Endpoint_Control_IO,
        ep13: Endpoint_Control_IO,
        ep14: Endpoint_Control_IO,
        ep15: Endpoint_Control_IO,
    },
    buffer_control: extern struct {
        ep0: Buffer_Control_IO,
        ep1: Buffer_Control_IO,
        ep2: Buffer_Control_IO,
        ep3: Buffer_Control_IO,
        ep4: Buffer_Control_IO,
        ep5: Buffer_Control_IO,
        ep6: Buffer_Control_IO,
        ep7: Buffer_Control_IO,
        ep8: Buffer_Control_IO,
        ep9: Buffer_Control_IO,
        ep10: Buffer_Control_IO,
        ep11: Buffer_Control_IO,
        ep12: Buffer_Control_IO,
        ep13: Buffer_Control_IO,
        ep14: Buffer_Control_IO,
        ep15: Buffer_Control_IO,
    },

    /// note buffer 0 is always used for EP0 setup transfers
    buffer: [60][64]u8,
};

pub const Endpoint_IO_Bitmap = packed struct(u2) {
    in: bool = false,
    out: bool = false,
};

pub const Endpoint_Bitmap = packed struct(u32) {
    ep0: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep1: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep2: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep3: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep4: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep5: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep6: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep7: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep8: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep9: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep10: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep11: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep12: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep13: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep14: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
    ep15: Endpoint_IO_Bitmap = @bitCast(@as(u2, 0)),
};

pub const Endpoint_IO_Buffer_Select = packed struct(u2) {
    in: u1 = 0,
    out: u1 = 0,
};

pub const Endpoint_Buffer_Select = packed struct(u32) {
    ep0: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep1: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep2: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep3: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep4: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep5: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep6: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep7: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep8: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep9: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep10: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep11: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep12: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep13: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep14: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
    ep15: Endpoint_IO_Buffer_Select = @bitCast(@as(u2, 0)),
};

pub const Signal_Override = packed struct(u2) {
    override_value: bool = false,
    override_enabled: bool = false,
};

pub const Device_Interrupt_Bitmap = packed struct(u32) {
    _reserved_0: u3 = 0,
    transaction_complete: bool = false,
    buffer_transfer_complete: bool = false,
    data_sequence_error: bool = false,
    ack_timeout: bool = false,
    rx_overflow_error: bool = false,
    bit_stuffing_error: bool = false,
    crc_mismatch: bool = false,
    stall: bool = false,
    vbus_detect: bool = false,
    bus_reset: bool = false,
    connection_state: bool = false,
    suspend_state: bool = false,
    resume_from_host: bool = false,
    setup_request: bool = false,
    start_of_frame: bool = false,
    abort_done: bool = false,
    stall_nak: bool = false,
    _reserved_14: u12 = 0,
};

pub const Host_Interrupt_Bitmap = packed struct(u32) {
    connection_state: bool = false,
    remote_resume: bool = false,
    start_of_frame: bool = false,
    transaction_complete: bool = false,
    buffer_transfer_complete: bool = false,
    data_sequence_error: bool = false,
    ack_timeout: bool = false,
    rx_overflow_error: bool = false,
    bit_stuffing_error: bool = false,
    crc_mismatch: bool = false,
    stall: bool = false,
    vbus_detect: bool = false,
    bus_reset: bool = false,
    _reserved_d: u6 = 0,
    stall_nak: bool = false,
    _reserved_14: u12 = 0,
};

pub const Control = packed struct(u32) {
    enabled: bool = false,
    mode: enum(u1) {
        device = 0,
        host = 1,
    } = .device,
    _reserved_2: u30 = 0,
};

pub const Frame_Number = packed struct(u32) {
    frame_number: u11 = 0,
    _reserved_b: u21 = 0,
};

pub const Muxing = packed struct(u32) {
    to_phy: bool = false,
    to_ext_phy: bool = false,
    to_digital_pad: bool = false,

    /// Undocumented 'SOFTCON' - set to true?
    software_control: bool = false,

    _reserved_4: u28 = 0,
};

pub const Power = packed struct(u32) {
    vbus_enable: Signal_Override = @bitCast(@as(u2, 0)),
    vbus_detect: Signal_Override = @bitCast(@as(u2, 0)),
    overcurrent_detect: Signal_Override = @bitCast(@as(u2, 0)),
    _reserved_6: u26 = 0,
};

pub const USB_DEV = extern struct {
    address: MMIO(u32, .rw),
    _reserved_4: [60]u8 = undefined,
    control: MMIO(Control, .rw),
    _reserved_44: [4]u8 = undefined,
    frame_number: MMIO(Frame_Number, .r),
    sie_control: MMIO(packed struct(u32) {
        _reserved_0: u12 = 0,
        trigger_remote_resume: bool = false,
        _reserved_d: u3 = 0,
        enable_pullups: bool = false,
        pullup_strength: enum(u1) {
            @"1.2k" = 0,
            @"2.3k" = 1,
        } = .@"1.2k",
        transceiver_powerdown: bool = false,
        _reserved_13: u8 = 0,
        ep0_enable_interrupt_on_nak: bool = false,
        ep0_enable_double_buffer_interrupt: bool = false,
        ep0_enable_buffer_interrupt: bool = false,
        ep0_double_buffered: bool = false,
        ep0_enable_interrupt_on_stall: bool = false,
    }, .rw),
    sie_status: MMIO(packed struct(u32) {
        vbus_detected: bool = false,
        _reserved_1: u3 = 0,

        /// Write true to clear
        suspended: bool = false,

        _reserved_5: u5 = 0,
        overcurrent_detected: bool = false,
        _reserved_b: u5 = 0,

        /// Write true to clear
        connected: bool = false,

        /// Write true to clear
        setup_packet_received: bool = false,

        /// Write true to clear
        transaction_complete: bool = false,

        /// Write true to clear
        bus_reset_detected: bool = false,

        _reserved_14: u4 = 0,

        /// Write true to clear
        crc_mismatch_detected: bool = false,

        /// Write true to clear
        bit_stuffing_error_detected: bool = false,

        /// Write true to clear
        rx_overflow_error_detected: bool = false,

        /// Write true to clear
        ack_timeout_detected: bool = false,

        _reserved_1c: u2 = 0,

        /// Write true to clear
        ack_received: bool = false,

        /// Write true to clear
        data_sequence_error_detected: bool = false,
    }, .rw),
    _reserved_54: [4]u8 = undefined,

    /// Write true to clear
    buffer_transfer_complete: MMIO(Endpoint_Bitmap, .rw),

    cpu_buffer_select: MMIO(Endpoint_Buffer_Select, .r),
    ep_abort: MMIO(Endpoint_Bitmap, .rw),

    /// Write true to clear
    ep_abort_complete: MMIO(Endpoint_Bitmap, .rw),

    ep0_stall_arm: MMIO(packed struct(u32) {
        in: u1 = 0,
        out: u1 = 0,
        _reserved_2: u30 = 0,
    }, .rw),
    _reserved_6c: [4]u8 = undefined,

    /// Write true to clear
    stall_nak_interrupt_status: MMIO(Endpoint_Bitmap, .rw),

    muxing: MMIO(Muxing, .rw),
    power: MMIO(Power, .rw),
    _reserved_7c: [16]u8 = undefined,
    interrupts: extern struct {
        raw: MMIO(Device_Interrupt_Bitmap, .r),
        enable: MMIO(Device_Interrupt_Bitmap, .rw),
        force: MMIO(Device_Interrupt_Bitmap, .rw),
        status: MMIO(Device_Interrupt_Bitmap, .r),
    },
};

pub const USB_HOST = extern struct {
    transfer_target: MMIO(packed struct(u32) {
        address: u7 = 0,
        _reserved_7: u9 = 0,
        endpoint: u4 = 0,
        _reserved_14: u12 = 0,
    }, .rw),
    interrupt_transfer_target: [15]MMIO(packed struct(u27) {
        address: u7 = 0,
        _reserved_7: u9 = 0,
        endpoint: u4 = 0,
        _reserved_14: u5 = 0,
        dir: enum(u1) {
            in = 0,
            out = 1,
        } = .in,
        enable_preamble: bool = false,
    }, .rw),
    control: MMIO(Control, .rw),
    set_frame_number: MMIO(Frame_Number, .w),
    last_sent_frame_number: MMIO(Frame_Number, .r),
    sie_control: MMIO(packed struct(u32) {
        trigger_start_transaction: bool = false,
        do_setup_packet: bool = false,
        do_out_packet: bool = false,
        do_in_packet: bool = false,
        trigger_stop_transaction: bool = false,
        _reserved_5: u1 = 0,
        enable_preamble: bool = false,
        _reserved_7: u1 = 0,
        delay_til_start_of_frame: bool = false,
        enable_start_of_frame_packets: bool = false,
        enable_keepalive: bool = false,
        enable_vbus: bool = false,
        _reserved_c: u1 = 0,
        trigger_bus_reset: bool = false,
        _reserved_e: u1 = 0,
        enable_pulldowns: bool = false,
        _reserved_10: u2 = 0,
        transceiver_powerdown: bool = false,
        _reserved_13: u11 = 0,
        ep0_double_buffered: bool = false,
        _reserved_1f: u1 = 0,
    }, .rw),
    sie_status: MMIO(packed struct(u32) {
        _reserved_0: u4 = 0,

        /// Write true to clear
        suspended: bool = false,

        _reserved_5: u3 = 0,
        speed: enum(u2) {
            disconnected = 0,
            low_speed = 1,
            full_speed = 2,
            _,
        } = .disconnected,
        overcurrent_detected: bool = false,

        /// Write true to clear
        remote_resume_detected: bool = false,

        _reserved_c: u6 = 0,

        /// Write true to clear
        transaction_complete: bool = false,

        _reserved_13: u5 = 0,

        /// Write true to clear
        crc_mismatch_detected: bool = false,

        /// Write true to clear
        bit_stuffing_error_detected: bool = false,

        /// Write true to clear
        rx_overflow_error_detected: bool = false,

        /// Write true to clear
        ack_timeout_detected: bool = false,

        /// Write true to clear
        nak_received: bool = false,

        /// Write true to clear
        stall_received: bool = false,

        /// Write true to clear
        ack_received: bool = false,

        /// Write true to clear
        data_sequence_error_detected: bool = false,
    }, .rw),
    endpoint_interrupt_control: MMIO(packed struct(u32) {
        _reserved_0: u1 = 0,
        enable_interrupt_transfers: packed struct(u15) {
            ep1: bool = false,
            ep2: bool = false,
            ep3: bool = false,
            ep4: bool = false,
            ep5: bool = false,
            ep6: bool = false,
            ep7: bool = false,
            ep8: bool = false,
            ep9: bool = false,
            ep10: bool = false,
            ep11: bool = false,
            ep12: bool = false,
            ep13: bool = false,
            ep14: bool = false,
            ep15: bool = false,
        } = @bitCast(@as(u15, 0)),
        _reserved_10: u16 = 0,
    }, .rw),

    /// Write true to clear
    buffer_transfer_complete: MMIO(Endpoint_Bitmap, .rw),

    cpu_buffer_select: MMIO(Endpoint_Buffer_Select, .r),
    _reserved_60: [12]u8 = undefined,
    nak_poll: MMIO(packed struct(u32) {
        interval_us_low_speed: u10 = 0x10,
        _reserved_a: u6 = 0,
        interval_us_full_speed: u10 = 0x10,
        _reserved_1a: u6 = 0,
    }, .rw),

    /// Write true to clear
    stall_nak_interrupt_status: MMIO(Endpoint_Bitmap, .rw),

    muxing: MMIO(Muxing, .rw),
    power: MMIO(Power, .rw),
    _reserved_7c: [8]u8 = undefined,
    pulldown_trim: MMIO(packed struct(u32) {
        dp: u5 = 0x1F,
        _reserved_5: u3 = 0,
        dm: u5 = 0x1F,
        _reserved_d: u19 = 0,
    }, .rw),
    _reserved_88: [4]u8 = undefined,
    interrupts: extern struct {
        raw: MMIO(Host_Interrupt_Bitmap, .r),
        enable: MMIO(Host_Interrupt_Bitmap, .rw),
        force: MMIO(Host_Interrupt_Bitmap, .rw),
        status: MMIO(Host_Interrupt_Bitmap, .r),
    },
};

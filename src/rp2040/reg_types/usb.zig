// Generated by https://github.com/bcrist/microbe-regz
const microbe = @import("microbe");
const chip = @import("chip");
const Mmio = microbe.Mmio;

pub const TransferKind = microbe.usb.endpoint.TransferKind;

pub const PID = microbe.usb.PID;

pub const DoubleBufferOffset = enum(u2) {
    @"128" = 0,
    @"256" = 1,
    @"512" = 2,
    @"1024" = 3,
};

pub const DeviceEndpointControl = packed struct(u32) {
    _reserved_0: u6 = 0,
    buffer_base: u10 = 0,
    enable_interrupt_on_nak: bool = false,
    enable_interrupt_on_stall: bool = false,
    _reserved_12: u8 = 0,
    transfer_kind: TransferKind = microbe.util.fromInt(TransferKind, 0),
    enable_double_buffer_interrupt: bool = false,
    enable_buffer_interrupt: bool = false,
    double_buffered: bool = false,
    enabled: bool = false,
};

pub const EndpointControlIO = extern union {
    host: extern struct {
        in: Mmio(packed struct(u32) {
            _reserved_0: u6 = 0,
            buffer_base: u10 = 0,
            poll_interval_ms_minus_one: u10 = 0,
            transfer_kind: TransferKind = microbe.util.fromInt(TransferKind, 0),
            enable_double_buffer_interrupt: bool = false,
            enable_buffer_interrupt: bool = false,
            double_buffered: bool = false,
            enabled: bool = false,
        }, .rw),
        _reserved_4: [4]u8 = undefined,
    },
    device: extern struct {
        in: Mmio(DeviceEndpointControl, .rw),
        out: Mmio(DeviceEndpointControl, .rw),
    },
};

pub const DeviceBufferControl0 = packed struct(u16) {
    len: u10 = 0,
    transfer_pending: bool = false,
    send_stall: bool = false,
    force_buffer_0: bool = false,
    pid: PID = microbe.util.fromInt(PID, 0),
    final_transfer: bool = false,
    full: bool = false,
};

pub const DeviceBufferControl1 = packed struct(u16) {
    len: u10 = 0,
    transfer_pending: bool = false,
    offset: DoubleBufferOffset = .@"128",
    pid: PID = microbe.util.fromInt(PID, 0),
    final_transfer: bool = false,
    full: bool = false,
};

pub const BufferControlIO = extern union {
    host: extern struct {
        in0: Mmio(packed struct(u16) {
            len: u10 = 0,
            transfer_pending: bool = false,
            stall_received: bool = false,
            _reserved_c: u1 = 0,
            pid: PID = microbe.util.fromInt(PID, 0),
            final_transfer: bool = false,
            full: bool = false,
        }, .rw),
        in1: Mmio(packed struct(u16) {
            len: u10 = 0,
            transfer_pending: bool = false,
            offset: DoubleBufferOffset = .@"128",
            pid: PID = microbe.util.fromInt(PID, 0),
            final_transfer: bool = false,
            full: bool = false,
        }, .rw),
        _reserved_4: [4]u8 = undefined,
    },
    device: extern struct {
        in0: Mmio(DeviceBufferControl0, .rw),
        in1: Mmio(DeviceBufferControl1, .rw),
        out0: Mmio(DeviceBufferControl0, .rw),
        out1: Mmio(DeviceBufferControl1, .rw),
    },
};

pub const USB_BUF = extern struct {
    setup_packet_low: Mmio(u32, .r),
    setup_packet_high: Mmio(u32, .r),
    ep_control: extern struct {
        ep1: EndpointControlIO,
        ep2: EndpointControlIO,
        ep3: EndpointControlIO,
        ep4: EndpointControlIO,
        ep5: EndpointControlIO,
        ep6: EndpointControlIO,
        ep7: EndpointControlIO,
        ep8: EndpointControlIO,
        ep9: EndpointControlIO,
        ep10: EndpointControlIO,
        ep11: EndpointControlIO,
        ep12: EndpointControlIO,
        ep13: EndpointControlIO,
        ep14: EndpointControlIO,
        ep15: EndpointControlIO,
    },
    buffer_control: extern struct {
        ep0: BufferControlIO,
        ep1: BufferControlIO,
        ep2: BufferControlIO,
        ep3: BufferControlIO,
        ep4: BufferControlIO,
        ep5: BufferControlIO,
        ep6: BufferControlIO,
        ep7: BufferControlIO,
        ep8: BufferControlIO,
        ep9: BufferControlIO,
        ep10: BufferControlIO,
        ep11: BufferControlIO,
        ep12: BufferControlIO,
        ep13: BufferControlIO,
        ep14: BufferControlIO,
        ep15: BufferControlIO,
    },

    /// note buffer 0 is always used for EP0 setup transfers
    buffer: [60][64]u8,
};

pub const EndpointIoBitmap = packed struct(u2) {
    in: bool = false,
    out: bool = false,
};

pub const EndpointBitmap = packed struct(u32) {
    ep0: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep1: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep2: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep3: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep4: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep5: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep6: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep7: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep8: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep9: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep10: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep11: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep12: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep13: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep14: EndpointIoBitmap = @bitCast(@as(u2, 0)),
    ep15: EndpointIoBitmap = @bitCast(@as(u2, 0)),
};

pub const EndpointIoBufferSelect = packed struct(u2) {
    in: u1 = 0,
    out: u1 = 0,
};

pub const EndpointBufferSelect = packed struct(u32) {
    ep0: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep1: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep2: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep3: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep4: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep5: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep6: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep7: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep8: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep9: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep10: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep11: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep12: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep13: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep14: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
    ep15: EndpointIoBufferSelect = @bitCast(@as(u2, 0)),
};

pub const SignalOverride = packed struct(u2) {
    override_value: bool = false,
    override_enabled: bool = false,
};

pub const DeviceInterruptBitmap = packed struct(u32) {
    _reserved_0: u3 = 0,
    transaction_complete: bool = false,
    buffer_transfer_complete: bool = false,
    data_sequence_error: bool = false,
    ack_timeout: bool = false,
    rx_overflow_error: bool = false,
    bit_stuffing_error: bool = false,
    crc_mismatch: bool = false,
    stall: bool = false,
    vbus_detect: bool = false,
    bus_reset: bool = false,
    connection_state: bool = false,
    suspend_state: bool = false,
    resume_from_host: bool = false,
    setup_request: bool = false,
    start_of_frame: bool = false,
    abort_done: bool = false,
    stall_nak: bool = false,
    _reserved_14: u12 = 0,
};

pub const HostInterruptBitmap = packed struct(u32) {
    connection_state: bool = false,
    remote_resume: bool = false,
    start_of_frame: bool = false,
    transaction_complete: bool = false,
    buffer_transfer_complete: bool = false,
    data_sequence_error: bool = false,
    ack_timeout: bool = false,
    rx_overflow_error: bool = false,
    bit_stuffing_error: bool = false,
    crc_mismatch: bool = false,
    stall: bool = false,
    vbus_detect: bool = false,
    bus_reset: bool = false,
    _reserved_d: u6 = 0,
    stall_nak: bool = false,
    _reserved_14: u12 = 0,
};

pub const Control = packed struct(u32) {
    enabled: bool = false,
    mode: enum(u1) {
        device = 0,
        host = 1,
    } = .device,
    _reserved_2: u30 = 0,
};

pub const FrameNumber = packed struct(u32) {
    frame_number: u11 = 0,
    _reserved_b: u21 = 0,
};

pub const Muxing = packed struct(u32) {
    to_phy: bool = false,
    to_ext_phy: bool = false,
    to_digital_pad: bool = false,

    /// Undocumented 'SOFTCON' - set to true?
    software_control: bool = false,

    _reserved_4: u28 = 0,
};

pub const Power = packed struct(u32) {
    vbus_enable: SignalOverride = @bitCast(@as(u2, 0)),
    vbus_detect: SignalOverride = @bitCast(@as(u2, 0)),
    overcurrent_detect: SignalOverride = @bitCast(@as(u2, 0)),
    _reserved_6: u26 = 0,
};

pub const USB_DEV = extern struct {
    address: Mmio(u32, .rw),
    _reserved_4: [60]u8 = undefined,
    control: Mmio(Control, .rw),
    _reserved_44: [4]u8 = undefined,
    frame_number: Mmio(FrameNumber, .r),
    sie_control: Mmio(packed struct(u32) {
        _reserved_0: u12 = 0,
        trigger_remote_resume: bool = false,
        _reserved_d: u3 = 0,
        enable_pullups: bool = false,
        pullup_strength: enum(u1) {
            @"1.2k" = 0,
            @"2.3k" = 1,
        } = .@"1.2k",
        transceiver_powerdown: bool = false,
        _reserved_13: u8 = 0,
        ep0_enable_interrupt_on_nak: bool = false,
        ep0_enable_double_buffer_interrupt: bool = false,
        ep0_enable_buffer_interrupt: bool = false,
        ep0_double_buffered: bool = false,
        ep0_enable_interrupt_on_stall: bool = false,
    }, .rw),
    sie_status: Mmio(packed struct(u32) {
        vbus_detected: bool = false,
        _reserved_1: u3 = 0,

        /// Write true to clear
        suspended: bool = false,

        _reserved_5: u5 = 0,
        overcurrent_detected: bool = false,
        _reserved_b: u5 = 0,

        /// Write true to clear
        connected: bool = false,

        /// Write true to clear
        setup_packet_received: bool = false,

        /// Write true to clear
        transaction_complete: bool = false,

        /// Write true to clear
        bus_reset_detected: bool = false,

        _reserved_14: u4 = 0,

        /// Write true to clear
        crc_mismatch_detected: bool = false,

        /// Write true to clear
        bit_stuffing_error_detected: bool = false,

        /// Write true to clear
        rx_overflow_error_detected: bool = false,

        /// Write true to clear
        ack_timeout_detected: bool = false,

        _reserved_1c: u2 = 0,

        /// Write true to clear
        ack_received: bool = false,

        /// Write true to clear
        data_sequence_error_detected: bool = false,
    }, .rw),
    _reserved_54: [4]u8 = undefined,

    /// Write true to clear
    buffer_transfer_complete: Mmio(EndpointBitmap, .rw),

    cpu_buffer_select: Mmio(EndpointBufferSelect, .r),
    ep_abort: Mmio(EndpointBitmap, .rw),

    /// Write true to clear
    ep_abort_complete: Mmio(EndpointBitmap, .rw),

    ep0_stall_arm: Mmio(packed struct(u32) {
        in: u1 = 0,
        out: u1 = 0,
        _reserved_2: u30 = 0,
    }, .rw),
    _reserved_6c: [4]u8 = undefined,

    /// Write true to clear
    stall_nak_interrupt_status: Mmio(EndpointBitmap, .rw),

    muxing: Mmio(Muxing, .rw),
    power: Mmio(Power, .rw),
    _reserved_7c: [16]u8 = undefined,
    interrupts: extern struct {
        raw: Mmio(DeviceInterruptBitmap, .r),
        enable: Mmio(DeviceInterruptBitmap, .rw),
        force: Mmio(DeviceInterruptBitmap, .rw),
        status: Mmio(DeviceInterruptBitmap, .r),
    },
};

pub const USB_HOST = extern struct {
    transfer_target: Mmio(packed struct(u32) {
        address: u7 = 0,
        _reserved_7: u9 = 0,
        endpoint: u4 = 0,
        _reserved_14: u12 = 0,
    }, .rw),
    interrupt_transfer_target: [15]Mmio(packed struct(u27) {
        address: u7 = 0,
        _reserved_7: u9 = 0,
        endpoint: u4 = 0,
        _reserved_14: u5 = 0,
        dir: enum(u1) {
            in = 0,
            out = 1,
        } = .in,
        enable_preamble: bool = false,
    }, .rw),
    control: Mmio(Control, .rw),
    set_frame_number: Mmio(FrameNumber, .w),
    last_sent_frame_number: Mmio(FrameNumber, .r),
    sie_control: Mmio(packed struct(u32) {
        trigger_start_transaction: bool = false,
        do_setup_packet: bool = false,
        do_out_packet: bool = false,
        do_in_packet: bool = false,
        trigger_stop_transaction: bool = false,
        _reserved_5: u1 = 0,
        enable_preamble: bool = false,
        _reserved_7: u1 = 0,
        delay_til_start_of_frame: bool = false,
        enable_start_of_frame_packets: bool = false,
        enable_keepalive: bool = false,
        enable_vbus: bool = false,
        _reserved_c: u1 = 0,
        trigger_bus_reset: bool = false,
        _reserved_e: u1 = 0,
        enable_pulldowns: bool = false,
        _reserved_10: u2 = 0,
        transceiver_powerdown: bool = false,
        _reserved_13: u11 = 0,
        ep0_double_buffered: bool = false,
        _reserved_1f: u1 = 0,
    }, .rw),
    sie_status: Mmio(packed struct(u32) {
        _reserved_0: u4 = 0,

        /// Write true to clear
        suspended: bool = false,

        _reserved_5: u3 = 0,
        speed: enum(u2) {
            disconnected = 0,
            low_speed = 1,
            full_speed = 2,
            _,
        } = .disconnected,
        overcurrent_detected: bool = false,

        /// Write true to clear
        remote_resume_detected: bool = false,

        _reserved_c: u6 = 0,

        /// Write true to clear
        transaction_complete: bool = false,

        _reserved_13: u5 = 0,

        /// Write true to clear
        crc_mismatch_detected: bool = false,

        /// Write true to clear
        bit_stuffing_error_detected: bool = false,

        /// Write true to clear
        rx_overflow_error_detected: bool = false,

        /// Write true to clear
        ack_timeout_detected: bool = false,

        /// Write true to clear
        nak_received: bool = false,

        /// Write true to clear
        stall_received: bool = false,

        /// Write true to clear
        ack_received: bool = false,

        /// Write true to clear
        data_sequence_error_detected: bool = false,
    }, .rw),
    endpoint_interrupt_control: Mmio(packed struct(u32) {
        _reserved_0: u1 = 0,
        enable_interrupt_transfers: packed struct(u15) {
            ep1: bool = false,
            ep2: bool = false,
            ep3: bool = false,
            ep4: bool = false,
            ep5: bool = false,
            ep6: bool = false,
            ep7: bool = false,
            ep8: bool = false,
            ep9: bool = false,
            ep10: bool = false,
            ep11: bool = false,
            ep12: bool = false,
            ep13: bool = false,
            ep14: bool = false,
            ep15: bool = false,
        } = @bitCast(@as(u15, 0)),
        _reserved_10: u16 = 0,
    }, .rw),

    /// Write true to clear
    buffer_transfer_complete: Mmio(EndpointBitmap, .rw),

    cpu_buffer_select: Mmio(EndpointBufferSelect, .r),
    _reserved_60: [12]u8 = undefined,
    nak_poll: Mmio(packed struct(u32) {
        interval_us_low_speed: u10 = 0x10,
        _reserved_a: u6 = 0,
        interval_us_full_speed: u10 = 0x10,
        _reserved_1a: u6 = 0,
    }, .rw),

    /// Write true to clear
    stall_nak_interrupt_status: Mmio(EndpointBitmap, .rw),

    muxing: Mmio(Muxing, .rw),
    power: Mmio(Power, .rw),
    _reserved_7c: [8]u8 = undefined,
    pulldown_trim: Mmio(packed struct(u32) {
        dp: u5 = 0x1F,
        _reserved_5: u3 = 0,
        dm: u5 = 0x1F,
        _reserved_d: u19 = 0,
    }, .rw),
    _reserved_88: [4]u8 = undefined,
    interrupts: extern struct {
        raw: Mmio(HostInterruptBitmap, .r),
        enable: Mmio(HostInterruptBitmap, .rw),
        force: Mmio(HostInterruptBitmap, .rw),
        status: Mmio(HostInterruptBitmap, .r),
    },
};

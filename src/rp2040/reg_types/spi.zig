// Generated by https://github.com/bcrist/microbe-regz
const microbe = @import("microbe");
const chip = @import("chip");
const MMIO = microbe.MMIO;

pub const Interrupt_Bitmap = packed struct(u32) {
    rx_overrun: bool = false,
    rx_timeout: bool = false,
    rx_fifo: bool = false,
    tx_fifo: bool = false,
    _reserved_4: u28 = 0,
};

pub const Data_Bits = enum(u4) {
    four = 3,
    five = 4,
    six = 5,
    seven = 6,
    eight = 7,
    nine = 8,
    ten = 9,
    eleven = 10,
    twelve = 11,
    thirteen = 12,
    fourteen = 13,
    fifteen = 14,
    sixteen = 15,
    _,
};

pub const Format = enum(u4) {
    /// Latch data on rising clock, clock idles low
    spi_mode_0 = 0,

    ssp = 1,
    microwire = 2,

    /// Latch data on falling clock, clock idles high
    spi_mode_2 = 4,

    /// Latch data on falling clock, clock idles low
    spi_mode_1 = 8,

    /// Latch data on rising clock, clock idles high
    spi_mode_3 = 12,

    _,
};

pub const SPI = extern struct {
    control0: MMIO(packed struct(u32) {
        data_bits: Data_Bits = @enumFromInt(0),
        format: Format = .spi_mode_0,
        clock_rate_factor: u8 = 0,
        _reserved_10: u16 = 0,
    }, .rw),
    control1: MMIO(packed struct(u32) {
        loopback: bool = false,
        enabled: bool = false,
        role: enum(u1) {
            controller = 0,
            device = 1,
        } = .controller,
        _reserved_3: u29 = 0,
    }, .rw),
    fifo: MMIO(packed struct(u32) {
        data: u16 = 0,
        _reserved_10: u16 = 0,
    }, .rw),
    status: MMIO(packed struct(u32) {
        tx_fifo_empty: bool = true,
        tx_fifo_not_full: bool = true,
        rx_fifo_not_empty: bool = false,
        rx_fifo_full: bool = false,
        transfer_in_progress: bool = false,
        _reserved_5: u27 = 0,
    }, .rw),
    clock_prescale: MMIO(packed struct(u32) {
        /// Must be multiple of 2
        divisor: u8 = 0,

        _reserved_8: u24 = 0,
    }, .rw),
    irq: extern struct {
        enable: MMIO(Interrupt_Bitmap, .rw),
        raw: MMIO(Interrupt_Bitmap, .r),
        status: MMIO(Interrupt_Bitmap, .r),
        clear: MMIO(packed struct(u32) {
            rx_overrun: bool = false,
            rx_timeout: bool = false,
            _reserved_2: u30 = 0,
        }, .rw),
    },
    dma_control: MMIO(packed struct(u32) {
        rx_enable: bool = false,
        tx_enable: bool = false,
        _reserved_2: u30 = 0,
    }, .rw),
};
